<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Transparency Sandbox</title>
    <style>
        :root {
            color-scheme: light dark;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        }
        body {
            margin: 1.5rem;
            max-width: 960px;
        }
        h1 {
            margin-bottom: 0.75rem;
        }
        fieldset {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 0.75rem;
            border: 1px solid rgba(127, 127, 127, 0.4);
            padding: 1rem;
            margin-block: 1rem;
        }
        label {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            font-size: 0.9rem;
        }
        input[type="number"],
        input[type="file"] {
            font-size: 0.95rem;
        }
        button {
            padding: 0.6rem 1.3rem;
            font-size: 1rem;
        }
        .preview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 1.5rem;
            margin-top: 1.5rem;
        }
        .preview {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .preview img {
            width: 100%;
            height: auto;
            object-fit: contain;
            background:
                conic-gradient(from 45deg, #ddd 0 25%, #fff 0 50%, #ddd 0 75%, #fff 0),
                repeating-conic-gradient(#ddd 0 25%, #fff 0 50%);
            background-size: 32px 32px;
            border: 1px solid rgba(127, 127, 127, 0.4);
            border-radius: 6px;
            padding: 0.5rem;
        }
        #log {
            margin-top: 1rem;
            font-size: 0.9rem;
            white-space: pre-wrap;
        }
        a[download] {
            font-size: 0.95rem;
            margin-top: 0.25rem;
        }
    </style>
</head>
<body>
    <h1>Background Transparency Sandbox</h1>
    <p>Select a PNG from disk, tweak the knobs, and hit the button to run the canvas-based background remover.</p>

    <div>
        <input id="fileInput" type="file" accept="image/png,image/jpeg,image/webp">
    </div>

    <fieldset>
        <legend>Options</legend>
        <label>
            Color tolerance
            <input id="colorTol" type="number" value="10" min="1" max="100">
        </label>
        <label>
            Tile guess
            <input id="tileGuess" type="number" value="16" min="4" max="64">
        </label>
        <label>
            Gradient keep
            <input id="gradKeep" type="number" value="10" min="0" max="64">
        </label>
        <label>
            Feather radius
            <input id="feather" type="number" value="2" min="0" max="32">
        </label>
    </fieldset>

    <button id="runBtn" disabled>Remove Background</button>

    <div class="preview-grid">
        <div class="preview">
            <h2>Original</h2>
            <img id="originalPreview" alt="Original preview placeholder">
        </div>
        <div class="preview">
            <h2>Processed</h2>
            <img id="processedPreview" alt="Processed preview placeholder">
            <a id="downloadLink" download="processed.png" hidden>Download PNG</a>
        </div>
    </div>

    <pre id="log"></pre>

    <script>
        const fileInput = document.getElementById('fileInput');
        const runBtn = document.getElementById('runBtn');
        const originalPreview = document.getElementById('originalPreview');
        const processedPreview = document.getElementById('processedPreview');
        const downloadLink = document.getElementById('downloadLink');
        const logView = document.getElementById('log');

        const optionInputs = {
            colorTol: document.getElementById('colorTol'),
            tileGuess: document.getElementById('tileGuess'),
            gradKeep: document.getElementById('gradKeep'),
            feather: document.getElementById('feather'),
        };

        let currentDataUrl = null;

        const log = (text) => {
            const timestamp = new Date().toLocaleTimeString();
            logView.textContent = `[${timestamp}] ${text}`;
        };

        fileInput.addEventListener('change', () => {
            const file = fileInput.files?.[0];
            if (!file) {
                currentDataUrl = null;
                originalPreview.removeAttribute('src');
                processedPreview.removeAttribute('src');
                runBtn.disabled = true;
                downloadLink.hidden = true;
                log('Waiting for image...');
                return;
            }
            const reader = new FileReader();
            reader.onload = () => {
                currentDataUrl = reader.result;
                originalPreview.src = currentDataUrl;
                processedPreview.removeAttribute('src');
                downloadLink.hidden = true;
                runBtn.disabled = false;
                log(`Loaded ${file.name} (${Math.round(file.size / 1024)} KB)`);
            };
            reader.onerror = () => {
                log('Failed to read file.');
            };
            reader.readAsDataURL(file);
        });

        runBtn.addEventListener('click', async () => {
            if (!currentDataUrl) {
                log('Please select an image first.');
                return;
            }
            runBtn.disabled = true;
            log('Processing...');
            try {
                const opts = {
                    colorTol: Number(optionInputs.colorTol.value),
                    tileGuess: Number(optionInputs.tileGuess.value),
                    gradKeep: Number(optionInputs.gradKeep.value),
                    feather: Number(optionInputs.feather.value),
                };
                const processedUrl = await makeBackgroundTransparent(currentDataUrl, opts);
                processedPreview.src = processedUrl;
                downloadLink.href = processedUrl;
                downloadLink.hidden = false;
                log('Done!');
            } catch (err) {
                console.error(err);
                log(`Error: ${err instanceof Error ? err.message : String(err)}`);
            } finally {
                runBtn.disabled = false;
            }
        });

        const loadImage = (src) => new Promise((resolve, reject) => {
            const image = new Image();
            image.crossOrigin = 'anonymous';
            image.onload = () => resolve(image);
            image.onerror = () => reject(new Error('Image failed to load'));
            image.src = src;
        });

        const srgbToLinear = (value) =>
            value <= 0.04045 ? value / 12.92 : Math.pow((value + 0.055) / 1.055, 2.4);

        const labF = (t) => (t > 0.008856 ? Math.cbrt(t) : 7.787 * t + 16 / 116);

        const rgbToLab = (r, g, b) => {
            const R = srgbToLinear(r / 255);
            const G = srgbToLinear(g / 255);
            const B = srgbToLinear(b / 255);

            const X = 0.4124564 * R + 0.3575761 * G + 0.1804375 * B;
            const Y = 0.2126729 * R + 0.7151522 * G + 0.072175 * B;
            const Z = 0.0193339 * R + 0.119192 * G + 0.9503041 * B;
            const xn = 0.95047;
            const yn = 1.0;
            const zn = 1.08883;

            const fx = labF(X / xn);
            const fy = labF(Y / yn);
            const fz = labF(Z / zn);

            return [116 * fy - 16, 500 * (fx - fy), 200 * (fy - fz)];
        };

        const distLab = (l, a, b, ref) => {
            const dL = l - ref[0];
            const dA = a - ref[1];
            const dB = b - ref[2];
            return Math.sqrt(dL * dL + dA * dA + dB * dB);
        };

        const applyFeather = (mask, width, height, radius) => {
            if (radius <= 0) {
                return;
            }
            const tmp = new Float32Array(mask.length);

            for (let y = 0; y < height; y++) {
                const rowOffset = y * width;
                for (let x = 0; x < width; x++) {
                    const start = Math.max(0, x - radius);
                    const end = Math.min(width - 1, x + radius);
                    let sum = 0;
                    for (let xi = start; xi <= end; xi++) {
                        sum += mask[rowOffset + xi];
                    }
                    tmp[rowOffset + x] = sum / (end - start + 1);
                }
            }

            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    const start = Math.max(0, y - radius);
                    const end = Math.min(height - 1, y + radius);
                    let sum = 0;
                    for (let yi = start; yi <= end; yi++) {
                        sum += tmp[yi * width + x];
                    }
                    mask[y * width + x] = sum / (end - start + 1);
                }
            }
        };

        async function makeBackgroundTransparent(imageUrl, opts = {}) {
            const {
                colorTol = 10,
                tileGuess = 16,
                gradKeep = 10,
                feather = 2,
            } = opts;

            try {
                const img = await loadImage(imageUrl);
                const canvas = document.createElement('canvas');
                const width = canvas.width = img.width;
                const height = canvas.height = img.height;
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                if (!ctx) {
                    throw new Error('Could not get canvas context');
                }

                ctx.drawImage(img, 0, 0);
                const imgData = ctx.getImageData(0, 0, width, height);
                const data = imgData.data;
                const totalPixels = width * height;

                const labL = new Float32Array(totalPixels);
                const labA = new Float32Array(totalPixels);
                const labB = new Float32Array(totalPixels);
                const luminance = new Float32Array(totalPixels);

                for (let pixel = 0, offset = 0; pixel < totalPixels; pixel++, offset += 4) {
                    const r = data[offset];
                    const g = data[offset + 1];
                    const b = data[offset + 2];
                    const [L, A, B] = rgbToLab(r, g, b);
                    labL[pixel] = L;
                    labA[pixel] = A;
                    labB[pixel] = B;
                    luminance[pixel] = 0.2126 * r + 0.7152 * g + 0.0722 * b;
                }

                const samples = [];
                const addSample = (x, y) => {
                    if (x < 0 || x >= width || y < 0 || y >= height) {
                        return;
                    }
                    const offset = (y * width + x) * 4;
                    samples.push([data[offset], data[offset + 1], data[offset + 2]]);
                };

                const edgeStep = Math.max(1, Math.floor(Math.min(width, height) / Math.max(8, tileGuess)));
                for (let x = 0; x < width; x += edgeStep) {
                    addSample(x, 0);
                    addSample(x, height - 1);
                }
                for (let y = 0; y < height; y += edgeStep) {
                    addSample(0, y);
                    addSample(width - 1, y);
                }
                addSample(0, 0);
                addSample(width - 1, 0);
                addSample(0, height - 1);
                addSample(width - 1, height - 1);

                if (samples.length === 0) {
                    return imageUrl;
                }

                const clusters = [];
                const clusterMergeTol = Math.max(4, colorTol * 0.6);

                for (const rgb of samples) {
                    const lab = rgbToLab(rgb[0], rgb[1], rgb[2]);
                    let bestIndex = -1;
                    let bestDist = Number.POSITIVE_INFINITY;
                    clusters.forEach((cluster, index) => {
                        const d = distLab(lab[0], lab[1], lab[2], cluster.lab);
                        if (d < clusterMergeTol && d < bestDist) {
                            bestDist = d;
                            bestIndex = index;
                        }
                    });
                    if (bestIndex >= 0) {
                        const cluster = clusters[bestIndex];
                        const count = cluster.count + 1;
                        cluster.lab = [
                            (cluster.lab[0] * cluster.count + lab[0]) / count,
                            (cluster.lab[1] * cluster.count + lab[1]) / count,
                            (cluster.lab[2] * cluster.count + lab[2]) / count,
                        ];
                        cluster.rgb = [
                            (cluster.rgb[0] * cluster.count + rgb[0]) / count,
                            (cluster.rgb[1] * cluster.count + rgb[1]) / count,
                            (cluster.rgb[2] * cluster.count + rgb[2]) / count,
                        ];
                        cluster.count = count;
                    } else {
                        clusters.push({ lab, rgb, count: 1 });
                    }
                }

                clusters.sort((a, b) => b.count - a.count);
                const bgClusters = clusters.slice(0, Math.min(2, clusters.length));
                if (bgClusters.length === 0) {
                    return imageUrl;
                }

                const bgLabs = bgClusters.map((cluster) => cluster.lab.slice());
                if (bgLabs.length === 1) {
                    bgLabs.push(bgLabs[0]);
                }

                let tolerance = Math.max(colorTol, 12);
                if (bgLabs.length >= 2) {
                    const lab1 = bgLabs[0];
                    const lab2 = bgLabs[1];
                    const clusterDistance = distLab(lab1[0], lab1[1], lab1[2], lab2);
                    tolerance = Math.min(45, Math.max(tolerance, clusterDistance * 0.45));
                }

                const grad = new Float32Array(totalPixels);
                for (let y = 1; y < height - 1; y++) {
                    const row = y * width;
                    for (let x = 1; x < width - 1; x++) {
                        const idx = row + x;
                        const lum = (yy, xx) => luminance[yy * width + xx];
                        const gx =
                            -lum(y - 1, x - 1) -
                            2 * lum(y, x - 1) -
                            lum(y + 1, x - 1) +
                            lum(y - 1, x + 1) +
                            2 * lum(y, x + 1) +
                            lum(y + 1, x + 1);
                        const gy =
                            -lum(y - 1, x - 1) -
                            2 * lum(y - 1, x) -
                            lum(y - 1, x + 1) +
                            lum(y + 1, x - 1) +
                            2 * lum(y + 1, x) +
                            lum(y + 1, x + 1);
                        grad[idx] = Math.hypot(gx, gy) / 8;
                    }
                }

                const distanceToBackground = (index) => {
                    const l = labL[index];
                    const a = labA[index];
                    const b = labB[index];
                    let shortest = Number.POSITIVE_INFINITY;
                    for (const lab of bgLabs) {
                        const d = distLab(l, a, b, lab);
                        if (d < shortest) {
                            shortest = d;
                        }
                    }
                    return shortest;
                };

                const queueX = new Int32Array(totalPixels);
                const queueY = new Int32Array(totalPixels);
                const visited = new Uint8Array(totalPixels);
                let head = 0;
                let tail = 0;

                const tryEnqueue = (x, y, force = false) => {
                    if (x < 0 || x >= width || y < 0 || y >= height) {
                        return;
                    }
                    const idx = y * width + x;
                    if (visited[idx]) {
                        return;
                    }
                    const dist = distanceToBackground(idx);
                    const threshold = force ? tolerance * 1.35 : tolerance;
                    if (dist > threshold) {
                        return;
                    }
                    if (!force && gradKeep > 0 && grad[idx] > gradKeep && dist > tolerance * 0.4) {
                        return;
                    }
                    visited[idx] = 1;
                    queueX[tail] = x;
                    queueY[tail] = y;
                    tail++;
                };

                for (let x = 0; x < width; x += edgeStep) {
                    tryEnqueue(x, 0, true);
                    tryEnqueue(x, height - 1, true);
                }
                for (let y = 0; y < height; y += edgeStep) {
                    tryEnqueue(0, y, true);
                    tryEnqueue(width - 1, y, true);
                }

                const neighbours = [
                    [1, 0],
                    [-1, 0],
                    [0, 1],
                    [0, -1],
                ];

                while (head < tail) {
                    const x = queueX[head];
                    const y = queueY[head];
                    head++;
                    for (const [dx, dy] of neighbours) {
                        tryEnqueue(x + dx, y + dy);
                    }
                }

                const mask = new Float32Array(totalPixels);
                for (let i = 0; i < totalPixels; i++) {
                    mask[i] = visited[i] ? 1 : 0;
                }

                if (feather > 0) {
                    const radius = Math.max(1, Math.floor(feather));
                    applyFeather(mask, width, height, radius);
                }

                for (let pixel = 0, offset = 0; pixel < totalPixels; pixel++, offset += 4) {
                    data[offset + 3] = Math.round((1 - mask[pixel]) * 255);
                }

                ctx.putImageData(imgData, 0, 0);
                return canvas.toDataURL('image/png');
            } catch (error) {
                console.error('Error processing image for transparency:', error);
                return imageUrl;
            }
        }
    </script>
</body>
</html>
