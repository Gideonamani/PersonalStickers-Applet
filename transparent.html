<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Transparency Sandbox</title>
    <style>
        :root {
            color-scheme: light dark;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        }
        body {
            margin: 1.5rem;
            max-width: 960px;
        }
        h1 {
            margin-bottom: 0.75rem;
        }
        input[type="file"] {
            font-size: 0.95rem;
        }
        button {
            padding: 0.6rem 1.3rem;
            font-size: 1rem;
        }
        .preview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 1.5rem;
            margin-top: 1.5rem;
        }
        .preview {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .preview-frame {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 280px;
            background:
                conic-gradient(from 45deg, #ddd 0 25%, #fff 0 50%, #ddd 0 75%, #fff 0),
                repeating-conic-gradient(#ddd 0 25%, #fff 0 50%);
            background-size: 32px 32px;
            border: 1px solid rgba(127, 127, 127, 0.4);
            border-radius: 6px;
            padding: 0.5rem;
            box-sizing: border-box;
            overflow: hidden;
        }
        .preview-frame img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            display: block;
            border-radius: 4px;
        }
        .preview-frame.pick-mode {
            cursor: crosshair;
        }
        .preview-frame.pick-mode.disabled {
            cursor: not-allowed;
        }
        .seed-marker {
            position: absolute;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 2px solid #ffffff;
            background: #ff6b6b;
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
            color: #fff;
            box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.25);
        }
        .seed-toolbar {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .seed-toolbar p {
            margin: 0;
            font-size: 0.9rem;
            color: #333;
        }
        .seed-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
        }
        .seed-buttons button {
            padding: 0.45rem 1rem;
            border-radius: 6px;
            border: 1px solid #d0d0d0;
            background: #f7f7f7;
            color: #333;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }
        .seed-buttons button:hover:not(:disabled) {
            background: #ebebeb;
            border-color: #c0c0c0;
        }
        .seed-buttons button:disabled {
            opacity: 0.55;
            cursor: not-allowed;
        }
        #log {
            margin-top: 1rem;
            font-size: 0.9rem;
            white-space: pre-wrap;
        }
        a[download] {
            font-size: 0.95rem;
            margin-top: 0.25rem;
        }
    </style>
</head>
<body>
    <h1>Background Transparency Sandbox</h1>
    <p>Select a PNG from disk, hit the button once, then click any remaining background regions in the processed preview to clean them up.</p>

    <div>
        <input id="fileInput" type="file" accept="image/png,image/jpeg,image/webp">
    </div>

    <button id="runBtn" disabled>Remove Background</button>

    <div class="preview-grid">
        <div class="preview">
            <h2>Original</h2>
            <div class="preview-frame" id="originalFrame">
                <img id="originalPreview" alt="Original preview placeholder">
            </div>
        </div>
        <div class="preview">
            <h2>Processed</h2>
            <div class="preview-frame pick-mode disabled" id="processedFrame">
                <img id="processedPreview" alt="Processed preview placeholder">
            </div>
            <div class="seed-toolbar">
                <p>Click anywhere on the processed image to sample background you still see. Each pick triggers a quick reprocess.</p>
                <p id="seedStatus">No seeds yet — click the processed image to add a sampling point.</p>
                <div class="seed-buttons">
                    <button id="undoSeedBtn" disabled>Undo seed</button>
                    <button id="clearSeedsBtn" disabled>Clear seeds</button>
                </div>
            </div>
            <a id="downloadLink" download="processed.png" hidden>Download PNG</a>
        </div>
    </div>

    <pre id="log"></pre>

    <script>
        const fileInput = document.getElementById('fileInput');
        const runBtn = document.getElementById('runBtn');
        const originalPreview = document.getElementById('originalPreview');
        const processedPreview = document.getElementById('processedPreview');
        const downloadLink = document.getElementById('downloadLink');
        const logView = document.getElementById('log');

        const processedFrame = document.getElementById('processedFrame');
        const seedStatusEl = document.getElementById('seedStatus');
        const undoSeedBtn = document.getElementById('undoSeedBtn');
        const clearSeedsBtn = document.getElementById('clearSeedsBtn');

        const DEFAULT_OPTIONS = {
            colorTol: 10,
            tileGuess: 16,
            gradKeep: 10,
            feather: 2,
        };

        let currentDataUrl = null;
        let seedPoints = [];
        let isProcessing = false;
        let processedDimensions = null;

        const baseSeedMessage = 'No seeds yet — click the processed image to add a sampling point.';

        const log = (text) => {
            const timestamp = new Date().toLocaleTimeString();
            logView.textContent = `[${timestamp}] ${text}`;
        };

        const refreshPickAvailability = () => {
            if (processedPreview.src) {
                processedFrame.classList.remove('disabled');
            } else {
                processedFrame.classList.add('disabled');
            }
        };

        const updateSeedUI = () => {
            const count = seedPoints.length;
            seedStatusEl.textContent = count
                ? `${count} seed${count === 1 ? '' : 's'} selected.`
                : baseSeedMessage;
            undoSeedBtn.disabled = count === 0;
            clearSeedsBtn.disabled = count === 0;
            processedFrame.querySelectorAll('.seed-marker').forEach(el => el.remove());
            if (!processedDimensions || !count) {
                return;
            }
            seedPoints.forEach((seed, index) => {
                const marker = document.createElement('span');
                marker.className = 'seed-marker';
                marker.textContent = index + 1;
                marker.style.left = `${(seed.x / processedDimensions.width) * 100}%`;
                marker.style.top = `${(seed.y / processedDimensions.height) * 100}%`;
                processedFrame.appendChild(marker);
            });
        };

        const processImage = async (message = 'Processing...') => {
            if (!currentDataUrl) {
                log('Please select an image first.');
                return;
            }
            if (isProcessing) {
                return;
            }
            isProcessing = true;
            runBtn.disabled = true;
            downloadLink.hidden = true;
            log(message);
            try {
                const options = {
                    ...DEFAULT_OPTIONS,
                    seedPoints,
                    mode: seedPoints.length ? 'auto+seed' : 'auto',
                };
                const processedUrl = await makeBackgroundTransparent(currentDataUrl, options);
                processedPreview.src = processedUrl;
                downloadLink.href = processedUrl;
                downloadLink.hidden = false;
                refreshPickAvailability();
                log('Done!');
            } catch (err) {
                console.error(err);
                log(`Error: ${err instanceof Error ? err.message : String(err)}`);
            } finally {
                isProcessing = false;
                runBtn.disabled = !currentDataUrl;
            }
        };

        fileInput.addEventListener('change', () => {
            const file = fileInput.files?.[0];
            if (!file) {
                currentDataUrl = null;
                originalPreview.removeAttribute('src');
                processedPreview.removeAttribute('src');
                processedDimensions = null;
                seedPoints = [];
                updateSeedUI();
                refreshPickAvailability();
                runBtn.disabled = true;
                downloadLink.hidden = true;
                log('Waiting for image...');
                return;
            }
            const reader = new FileReader();
            reader.onload = () => {
                currentDataUrl = reader.result;
                originalPreview.src = currentDataUrl;
                processedPreview.removeAttribute('src');
                processedDimensions = null;
                seedPoints = [];
                updateSeedUI();
                refreshPickAvailability();
                downloadLink.hidden = true;
                runBtn.disabled = false;
                log(`Loaded ${file.name} (${Math.round(file.size / 1024)} KB)`);
            };
            reader.onerror = () => {
                log('Failed to read file.');
            };
            reader.readAsDataURL(file);
        });

        runBtn.addEventListener('click', () => processImage('Processing...'));

        processedPreview.addEventListener('load', () => {
            processedDimensions = {
                width: processedPreview.naturalWidth,
                height: processedPreview.naturalHeight,
            };
            refreshPickAvailability();
            updateSeedUI();
        });

        processedFrame.addEventListener('click', (event) => {
            if (!processedPreview.src || !processedDimensions || isProcessing) {
                return;
            }
            const rect = processedPreview.getBoundingClientRect();
            if (!rect.width || !rect.height) {
                return;
            }
            if (
                event.clientX < rect.left ||
                event.clientX > rect.right ||
                event.clientY < rect.top ||
                event.clientY > rect.bottom
            ) {
                return;
            }
            const relativeX = (event.clientX - rect.left) / rect.width;
            const relativeY = (event.clientY - rect.top) / rect.height;
            const x = relativeX * processedDimensions.width;
            const y = relativeY * processedDimensions.height;
            if (!Number.isFinite(x) || !Number.isFinite(y)) {
                return;
            }
            seedPoints = [...seedPoints, { x, y, force: true }];
            updateSeedUI();
            processImage('Applying seed...');
        });

        undoSeedBtn.addEventListener('click', () => {
            if (!seedPoints.length || isProcessing) {
                return;
            }
            seedPoints = seedPoints.slice(0, -1);
            updateSeedUI();
            processImage('Updating transparency...');
        });

        clearSeedsBtn.addEventListener('click', () => {
            if (!seedPoints.length || isProcessing) {
                return;
            }
            seedPoints = [];
            updateSeedUI();
            processImage('Reprocessing without manual seeds...');
        });

        updateSeedUI();
        refreshPickAvailability();

        const loadImage = (src) => new Promise((resolve, reject) => {
            const image = new Image();
            image.crossOrigin = 'anonymous';
            image.onload = () => resolve(image);
            image.onerror = () => reject(new Error('Image failed to load'));
            image.src = src;
        });

        const srgbToLinear = (value) =>
            value <= 0.04045 ? value / 12.92 : Math.pow((value + 0.055) / 1.055, 2.4);

        const labF = (t) => (t > 0.008856 ? Math.cbrt(t) : 7.787 * t + 16 / 116);

        const rgbToLab = (r, g, b) => {
            const R = srgbToLinear(r / 255);
            const G = srgbToLinear(g / 255);
            const B = srgbToLinear(b / 255);

            const X = 0.4124564 * R + 0.3575761 * G + 0.1804375 * B;
            const Y = 0.2126729 * R + 0.7151522 * G + 0.072175 * B;
            const Z = 0.0193339 * R + 0.119192 * G + 0.9503041 * B;
            const xn = 0.95047;
            const yn = 1.0;
            const zn = 1.08883;

            const fx = labF(X / xn);
            const fy = labF(Y / yn);
            const fz = labF(Z / zn);

            return [116 * fy - 16, 500 * (fx - fy), 200 * (fy - fz)];
        };

        const distLab = (l, a, b, ref) => {
            const dL = l - ref[0];
            const dA = a - ref[1];
            const dB = b - ref[2];
            return Math.sqrt(dL * dL + dA * dA + dB * dB);
        };

        const applyFeather = (mask, width, height, radius) => {
            if (radius <= 0) {
                return;
            }
            const tmp = new Float32Array(mask.length);

            for (let y = 0; y < height; y++) {
                const rowOffset = y * width;
                for (let x = 0; x < width; x++) {
                    const start = Math.max(0, x - radius);
                    const end = Math.min(width - 1, x + radius);
                    let sum = 0;
                    for (let xi = start; xi <= end; xi++) {
                        sum += mask[rowOffset + xi];
                    }
                    tmp[rowOffset + x] = sum / (end - start + 1);
                }
            }

            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    const start = Math.max(0, y - radius);
                    const end = Math.min(height - 1, y + radius);
                    let sum = 0;
                    for (let yi = start; yi <= end; yi++) {
                        sum += tmp[yi * width + x];
                    }
                    mask[y * width + x] = sum / (end - start + 1);
                }
            }
        };

        async function makeBackgroundTransparent(imageUrl, opts = {}) {
            const {
                colorTol = 10,
                tileGuess = 16,
                gradKeep = 10,
                feather = 2,
                seedPoints = [],
                mode = 'auto',
            } = opts;

            try {
                const img = await loadImage(imageUrl);
                const canvas = document.createElement('canvas');
                const width = canvas.width = img.width;
                const height = canvas.height = img.height;
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                if (!ctx) {
                    throw new Error('Could not get canvas context');
                }

                ctx.drawImage(img, 0, 0);
                const imgData = ctx.getImageData(0, 0, width, height);
                const data = imgData.data;
                const totalPixels = width * height;

                const labL = new Float32Array(totalPixels);
                const labA = new Float32Array(totalPixels);
                const labB = new Float32Array(totalPixels);
                const luminance = new Float32Array(totalPixels);

                for (let pixel = 0, offset = 0; pixel < totalPixels; pixel++, offset += 4) {
                    const r = data[offset];
                    const g = data[offset + 1];
                    const b = data[offset + 2];
                    const [L, A, B] = rgbToLab(r, g, b);
                    labL[pixel] = L;
                    labA[pixel] = A;
                    labB[pixel] = B;
                    luminance[pixel] = 0.2126 * r + 0.7152 * g + 0.0722 * b;
                }

                const normalizeSeed = ({ x, y, force }) => ({
                    x: Math.max(0, Math.min(width - 1, Math.round(x))),
                    y: Math.max(0, Math.min(height - 1, Math.round(y))),
                    force: force ?? true,
                });
                const seeds = (seedPoints || []).map(normalizeSeed);

                const samples = [];
                const addSample = (x, y) => {
                    if (x < 0 || x >= width || y < 0 || y >= height) {
                        return;
                    }
                    const offset = (y * width + x) * 4;
                    samples.push([data[offset], data[offset + 1], data[offset + 2]]);
                };

                const edgeStep = Math.max(1, Math.floor(Math.min(width, height) / Math.max(8, tileGuess)));
                if (mode !== 'seed') {
                    for (let x = 0; x < width; x += edgeStep) {
                        addSample(x, 0);
                        addSample(x, height - 1);
                    }
                    for (let y = 0; y < height; y += edgeStep) {
                        addSample(0, y);
                        addSample(width - 1, y);
                    }
                    addSample(0, 0);
                    addSample(width - 1, 0);
                    addSample(0, height - 1);
                    addSample(width - 1, height - 1);
                }
                for (const { x, y } of seeds) {
                    for (let i = 0; i < 4; i++) {
                        addSample(x, y);
                    }
                }

                if (samples.length === 0) {
                    return imageUrl;
                }

                const clusters = [];
                const clusterMergeTol = Math.max(4, colorTol * 0.6);

                for (const rgb of samples) {
                    const lab = rgbToLab(rgb[0], rgb[1], rgb[2]);
                    let bestIndex = -1;
                    let bestDist = Number.POSITIVE_INFINITY;
                    clusters.forEach((cluster, index) => {
                        const d = distLab(lab[0], lab[1], lab[2], cluster.lab);
                        if (d < clusterMergeTol && d < bestDist) {
                            bestDist = d;
                            bestIndex = index;
                        }
                    });
                    if (bestIndex >= 0) {
                        const cluster = clusters[bestIndex];
                        const count = cluster.count + 1;
                        cluster.lab = [
                            (cluster.lab[0] * cluster.count + lab[0]) / count,
                            (cluster.lab[1] * cluster.count + lab[1]) / count,
                            (cluster.lab[2] * cluster.count + lab[2]) / count,
                        ];
                        cluster.rgb = [
                            (cluster.rgb[0] * cluster.count + rgb[0]) / count,
                            (cluster.rgb[1] * cluster.count + rgb[1]) / count,
                            (cluster.rgb[2] * cluster.count + rgb[2]) / count,
                        ];
                        cluster.count = count;
                    } else {
                        clusters.push({ lab, rgb: [...rgb], count: 1 });
                    }
                }

                clusters.sort((a, b) => b.count - a.count);
                const bgClusters = clusters.slice(0, Math.min(2, clusters.length));
                if (bgClusters.length < 2) {
                    for (const seed of seeds) {
                        const offset = (seed.y * width + seed.x) * 4;
                        const lab = rgbToLab(data[offset], data[offset + 1], data[offset + 2]);
                        const hasClose = bgClusters.some(cluster => distLab(lab[0], lab[1], lab[2], cluster.lab) < 2);
                        if (!hasClose) {
                            bgClusters.push({
                                lab,
                                rgb: [data[offset], data[offset + 1], data[offset + 2]],
                                count: 1,
                            });
                            if (bgClusters.length >= 2) {
                                break;
                            }
                        }
                    }
                }
                if (bgClusters.length === 0) {
                    return imageUrl;
                }

                const bgLabs = bgClusters.map((cluster) => cluster.lab.slice());
                if (bgLabs.length === 1) {
                    bgLabs.push(bgLabs[0]);
                }

                let tolerance = Math.max(colorTol, 12);
                if (bgLabs.length >= 2) {
                    const [lab1, lab2] = bgLabs;
                    const clusterDistance = distLab(lab1[0], lab1[1], lab1[2], lab2);
                    tolerance = Math.min(45, Math.max(tolerance, clusterDistance * 0.45));
                }

                const grad = new Float32Array(totalPixels);
                for (let y = 1; y < height - 1; y++) {
                    const row = y * width;
                    for (let x = 1; x < width - 1; x++) {
                        const idx = row + x;
                        const lum = (yy, xx) => luminance[yy * width + xx];
                        const gx =
                            -lum(y - 1, x - 1) -
                            2 * lum(y, x - 1) -
                            lum(y + 1, x - 1) +
                            lum(y - 1, x + 1) +
                            2 * lum(y, x + 1) +
                            lum(y + 1, x + 1);
                        const gy =
                            -lum(y - 1, x - 1) -
                            2 * lum(y - 1, x) -
                            lum(y - 1, x + 1) +
                            lum(y + 1, x - 1) +
                            2 * lum(y + 1, x) +
                            lum(y + 1, x + 1);
                        grad[idx] = Math.hypot(gx, gy) / 8;
                    }
                }

                const distanceToBackground = (index) => {
                    const l = labL[index];
                    const a = labA[index];
                    const b = labB[index];
                    let shortest = Number.POSITIVE_INFINITY;
                    for (const lab of bgLabs) {
                        const d = distLab(l, a, b, lab);
                        if (d < shortest) {
                            shortest = d;
                        }
                    }
                    return shortest;
                };

                const queueX = new Int32Array(totalPixels);
                const queueY = new Int32Array(totalPixels);
                const visited = new Uint8Array(totalPixels);
                let head = 0;
                let tail = 0;

                const useAuto = mode !== 'seed';
                const useSeeds = seeds.length > 0 && mode !== 'auto';

                const tryEnqueue = (x, y, force = false) => {
                    if (x < 0 || x >= width || y < 0 || y >= height) {
                        return;
                    }
                    const idx = y * width + x;
                    if (visited[idx]) {
                        return;
                    }
                    const dist = distanceToBackground(idx);
                    const threshold = force ? tolerance * 1.35 : tolerance;
                    if (dist > threshold) {
                        return;
                    }
                    if (!force && gradKeep > 0 && grad[idx] > gradKeep && dist > tolerance * 0.4) {
                        return;
                    }
                    visited[idx] = 1;
                    queueX[tail] = x;
                    queueY[tail] = y;
                    tail++;
                };

                if (useAuto) {
                    for (let x = 0; x < width; x += edgeStep) {
                        tryEnqueue(x, 0, true);
                        tryEnqueue(x, height - 1, true);
                    }
                    for (let y = 0; y < height; y += edgeStep) {
                        tryEnqueue(0, y, true);
                        tryEnqueue(width - 1, y, true);
                    }
                }
                if (useSeeds) {
                    for (const seed of seeds) {
                        tryEnqueue(seed.x, seed.y, seed.force);
                    }
                }

                const neighbours = [
                    [1, 0],
                    [-1, 0],
                    [0, 1],
                    [0, -1],
                ];

                while (head < tail) {
                    const x = queueX[head];
                    const y = queueY[head];
                    head++;
                    for (const [dx, dy] of neighbours) {
                        tryEnqueue(x + dx, y + dy);
                    }
                }

                const mask = new Float32Array(totalPixels);
                for (let i = 0; i < totalPixels; i++) {
                    mask[i] = visited[i] ? 1 : 0;
                }

                if (feather > 0) {
                    const radius = Math.max(1, Math.floor(feather));
                    applyFeather(mask, width, height, radius);
                }

                for (let pixel = 0, offset = 0; pixel < totalPixels; pixel++, offset += 4) {
                    data[offset + 3] = Math.round((1 - mask[pixel]) * 255);
                }

                ctx.putImageData(imgData, 0, 0);
                return canvas.toDataURL('image/png');
            } catch (error) {
                console.error('Error processing image for transparency:', error);
                return imageUrl;
            }
        }
    </script>
</body>
</html>
